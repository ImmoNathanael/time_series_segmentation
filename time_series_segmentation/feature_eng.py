# AUTOGENERATED! DO NOT EDIT! File to edit: 01_feature_eng.ipynb (unless otherwise specified).

__all__ = ['add_seq_indicator', 'dataframe_split', 'feature_engineering_std', 'feature_engineering_mean',
           'feature_engineering_drift', 'get_features_basic', 'label_smoothing']

# Cell
import time
import pandas as pd
import numpy as np
import random

from fastcore.test import *
from time_series_segmentation import *

# Cell
def add_seq_indicator(data_index, seq_len=20):
    '''
    function to be used with apply in df.
    Assings sequence labels to sections of the data which allows us to randomly train/val/test splitt the subsequences.
    the acctual splitt

    Parameters:

    Output:

    '''
    return np.int(np.ceil((data_index.name+1)/seq_len))

# Cell
def dataframe_split(data, fraction = 0.1, random_state = 42, sep_col='seq_idx'):
    '''
    Creates a random split by the desired column
    '''
    if sep_col not in data.columns:
        data[sep_col] = data.apply(add_seq_indicator,seq_len=1000, axis=1)

    random.seed(random_state)
    sequence_numbers = data[sep_col].unique().tolist()
    k = int(np.ceil(data[sep_col].nunique()*fraction))
    split_list = random.sample(sequence_numbers, k=k)
    test = data.loc[data[sep_col].isin(split_list), :]
    train = data.drop(test.index)
    return train, test

# Cell
def feature_engineering_std(data, on_column, span=1):
    '''
    standard deviation of the bidirectional exponentially weighted mean

    Parameter:
    data: [pandas.DataFrame] in put data frame
    on_column: [string] on which column the operation should take place
    span: [integer] the span of the expo exponentially weighted mean

    Out:
    new feature, column of values that can be added to the data frame


    '''
    data_new = (data[on_column].ewm(span=span).std()+data[on_column].sort_index(ascending=False).ewm(span=span).std())/2
    data_new2 = data_new.fillna(method='ffill').fillna(method='bfill')
    assert (data_new2.isnull().sum().sum() == 0), 'check for NaNs in dtaframe'

    return data_new2

# Cell
def feature_engineering_mean(data, on_column, span=1):
    '''
    mean value of the bidirectional exponentially weighted mean

    Parameter:
    data: [pandas.DataFrame] in put data frame
    on_column: [string] on which column the operation should take place
    span: [integer] the span of the expo exponentially weighted mean

    Out:
    new feature, column of values that can be added to the data frame


    '''
    data_new = ((data[on_column].ewm(span=span).mean()+
                                    data[on_column].sort_index(ascending=False).ewm(span=span).mean())/2)
    assert (data_new.isnull().sum().sum() == 0), 'check for NaNs in dtaframe'

    return data_new

# Cell
def feature_engineering_drift(data, on_column, span=1):
    '''
    Local drift comparing the current value to the bidirectional exponentially weighted mean

    Parameter:
    data: [pandas.DataFrame] in put data frame
    on_column: [string] on which column the operation should take place
    span: [integer] the span of the expo exponentially weighted mean

    Out:
    new feature, column of values that can be added to the data frame


    '''
    data_new = data[on_column]-feature_engineering_mean(data, on_column, span)
    assert (data_new.isnull().sum().sum() == 0), 'check for NaNs in dtaframe'
    return data_new

# Cell
def get_features_basic(data):
    '''
    Basic example of combining several features:

    Thess example spans where chosen when working on the Liverpool Ion Channel
    dataset from Kaggle

    '''
    data.loc[:,'new_mean'] = feature_engineering_mean(data,'signal', span=10)
    data.loc[:,'std_long'] = feature_engineering_std(data, 'new_mean', span=1000)
    data.loc[:,'no_drift'] = feature_engineering_drift(data,'signal', span=1000)

    return data['no_drift'], data['std_long'], (data['no_drift']+(8*data['std_long']))

# Cell
def label_smoothing(data, data_cat_label, eps=0.1):
    '''
    A function that turns binary labels into smoothed labels. An explanation of when
    and why this is usefull is given in https://arxiv.org/pdf/1906.02629.pdf.

    The degree of smoothing is given by the smoothing parameter eps, which determines
    the value of of the resulting smoothed label.

    Input:
    Pandas dataframe contains.
    cat

    Output:
    Pandas dataframe containing the coresponding smoothed label columns.

    '''
    data_cat_label = data_cat_label.add_prefix('smoothed_')
    number_classes=data_cat_label.shape[-1]
    data =  pd.concat([data, data_cat_label.apply(lambda x: x*(1-eps)+(eps/number_classes))], axis=1)

    return data